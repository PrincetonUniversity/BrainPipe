#!/usr/bin/env python2
# -*- coding: utf-8 -*-
"""
Created on Fri Mar 30 11:44:25 2018

@author: tpisano
"""
import numpy as np, multiprocessing as mp,os, pandas as pd, time, sys
from tools.utils.io import makedir, chunkit, load_np, load_dictionary, save_kwargs, listdirfull, load_kwargs
from tools.utils.directorydeterminer import directorydeterminer as dd, pth_update
from tools.conv_net.functions.bipartite import pairwise_distance_metrics_multiple_cutoffs
from tools.objectdetection.evaluate_performance import compute_p_r_f1
import skimage
from skimage.feature import peak_local_max
from scipy import ndimage as ndi
from itertools import product
from tools.conv_net.functions.sphericity import filter_sphericity
from tools.conv_net.functions.size_filter import size_filter
from skimage.external import tifffile
from PIL import Image

if __name__ == '__main__':
    #single
    src = '/home/wanglab/wang/pisano/tracing_output/antero_4x/20161214_db_bl6_crii_l_53hr'
    kwargs = load_kwargs(src)
    cellvol = [xx for xx in kwargs['volumes'] if xx.ch_type == 'cellch'][0]
    vol = load_cnn_output(cellvol, threshold=1)
    
    #folder
    src = '/home/wanglab/wang/pisano/tracing_output/antero_4x/20161214_db_bl6_crii_l_53hr'

#%%
def find_intensity(zyx, src_raw, zyx_search_range=(2,10,10)):
    '''function to return maximum intensity of a determined center src_raw given a zyx point and search range

    src_cnn = '/home/wanglab/wang/pisano/tracing_output/antero_4x/20161214_db_bl6_crii_l_53hr/cells/20161214_db_bl6_crii_l_53hr_647_010na_z7d5um_75msec_5POVLP_ch00'
    src_raw = '/home/wanglab/wang/pisano/tracing_output/antero_4x/20161214_db_bl6_crii_l_53hr/full_sizedatafld/20161214_db_bl6_crii_l_53hr_647_010na_z7d5um_75msec_5POVLP_ch00'
    zyx_search_range=(4,10,10)
    zyx = (345, 3490, 3317)
    '''
    z,y,x = zyx
    zr,yr,xr = zyx_search_range
    rn = [(xx-yy, xx+yy+1) for xx,yy in zip(zyx, zyx_search_range)]
    fls = [xx for xx in listdirfull(src_raw, keyword = 'tif') if int(xx[xx.rfind('Z')+1:-4]) in range(rn[0][0], rn[0][1])]; fls.sort()
    arr = np.zeros((((zr*2)+1), ((yr*2)+1), ((xr*2)+1)))
    #a=[tifffile.imread(xx) for xx in fls]
    for i, fl in enumerate(fls):
        im = Image.open(fl)
        for ii,yy in enumerate(range(rn[1][0], rn[1][1])):
            for iii, xx in enumerate(range(rn[2][0], rn[2][1])):
                arr[i,ii,iii]=im.getpixel((xx,yy)) #PIL USES XY
    return np.max(arr)
                
    

def load_cnn_output(vol, threshold = 1):
    '''
    vol = volume class to process
    threshold = pixel value to threshold to zero (CNN outputs background as 0)
    '''
    pth = os.path.join(vol.outdr, 'cells', os.path.basename(vol.full_sizedatafld_vol))
    load_tiff_folder(pth, threshold = threshold)
    return vol 

def load_tiff_folder(src, threshold = 1, load_range = False, verbose=False):
    '''Function to load folder of tifffiles.
    
    src = path to folder
    threshold = value to zero out. For CNN should be 1
    load_range = tuple, zplane range to load, (34,48), NONnegative numbers
    
    '''
    #input structure
    fls = listdirfull(src, keyword='.tif'); fls.sort()
    im = tifffile.imread(fls[0], multifile=False)
    y,x=im.shape
    
    if load_range: 
        if load_range[0] < 0: load_range = tuple((0, load_range[1]))
        fls = fls[load_range[0]:load_range[1]]
    
    #load appropriate files
    vol = np.zeros((len(fls), y, x)).astype(im.dtype)
    for i,fl in enumerate(fls):
        im = tifffile.imread(fl, multifile=False)  
        if threshold: im[im<=threshold] = 0
        vol[i]=im
        if verbose: 
            if i%250 == 0: print('{} of {}'.format(i, len(fls)))  
    return vol
    

def filter_size(src, lower=175.0, upper=4500.0, threshold=1):
    '''
    '''
    if type(src) == str and src[-4:] == '.tif': 
        src = tifffile.imread(src)
        
    if type(src) == str and src[-4:] != '.tif':
        src = load_tiff_folder(src, threshold = threshold)
        
    labels = ndi.measurements.label(src)
    #vals, cnts = np.unique(labels[0], return_counts=True)
    arr = size_filter(labels, lower = lower, upper = upper)[0]
    arr[arr>0] = 1
    centers = probabilitymap_to_centers_thresh(arr, threshold = 0, numZSlicesPerSplit=250, overlapping_planes = 40, cores = 4, verbose = False)
    return centers
    
    
def probabilitymap_to_centers_thresh(src, threshold = 1, numZSlicesPerSplit=200, overlapping_planes = 40, cores = 4, return_pixels = False, verbose = True, **kwargs):
    '''Function to take probabilty maps generated by run_cnn and output centers based on center_of_mass

    Inputs:
    --------------
    src = folder containing list of tiffs
    threshold: note this assumes input from a CNN. Typically 1 = background
    numZSlicesPerSplit: chunk of zplanes to process at once. Adjust this and cores based on memory constraints.
    cores: number of parallel jobs to do at once. Adjust this and numZSlicesPerSplit based on memory constraints
    overlapping_planes: number of planes on each side to overlap by, this should be comfortably larger than the maximum z distances of a single object
    save (optional) 'True', 'False', str of path and file name to save with extension .p. If multiple cell channels.
    return_pixels, if True return centers and all pixels associated with that center

    Returns single list of
    ------------
    centers: list of zyx coordinates of centers of mass
    (IF RETURN PIXELS = True, dictionary consisting of k=centers, v=indices determined by cnn with k's center)
    save_location (if saving)

    OUTPUTS ZYX



    '''
    #handle inputs
    zdim = len(listdirfull(src, keyword='.tif'))

    #run
    iterlst=[(src, z, numZSlicesPerSplit, overlapping_planes, threshold, return_pixels) for z in range(0, zdim, numZSlicesPerSplit)]
    if cores<=1:
        start = time.time()
        centers=[]
        if verbose: sys.stdout.write('\n   Thesholding, determining connected pixels, identifying center of masses\n\n'); sys.stdout.flush()
        for i in iterlst:
            centers.append(helper_labels_centerofmass_thresh(i))
    else:
        start = time.time()
        if verbose: sys.stdout.write('\n   Thesholding, determining connected pixels, identifying center of masses\n\n'); sys.stdout.flush()
        p = mp.Pool(cores)
        
        centers = p.map(helper_labels_centerofmass_thresh, iterlst)
        p.terminate()
    #unpack
    if not return_pixels: centers = [zz for xx in centers for zz in xx]
    if return_pixels:
        center_pixels_dct = {}; [center_pixels_dct.update(xx) for xx in centers]
        centers = [zz for xx in centers for zz in xx]
        

    if verbose: print ('Total time {} minutes'.format(round((time.time() - start) / 60)))
    if verbose: print('{} objects found.'.format(len(centers)))

    if return_pixels: return center_pixels_dct
    return centers


def helper_labels_centerofmass_thresh((src, start, numZSlicesPerSplit, overlapping_planes, threshold, return_pixels)):
    '''
    '''
        #process
    if start == 0:
        arr = load_tiff_folder(src, threshold=threshold, load_range = (start, numZSlicesPerSplit+overlapping_planes))
        arr[arr>0]=1
        #find labels
        labels = ndi.measurements.label(arr); lbl_len = labels[1]
        centers = ndi.measurements.center_of_mass(arr, labels[0], range(1, labels[1]+1)); 
        #return pixels associated with a center
        if return_pixels: dct = return_pixels_associated_w_center(centers, labels)
        del labels, arr
        assert lbl_len == len(centers), 'Something went wrong, center of mass missed labels'
        #filter such that you only keep centers in first half
        centers = [center for center in centers if (center[0] <= numZSlicesPerSplit)]
        if return_pixels: dct = {c:dct[c] for c in centers}

    else: #cover 3x
        arr = load_tiff_folder(src, threshold=threshold, load_range = (start - overlapping_planes, start + numZSlicesPerSplit + overlapping_planes))
        arr[arr>0]=1
        zdim, ydim, xdim = arr.shape
        #find labels
        labels = ndi.measurements.label(arr)
        centers = ndi.measurements.center_of_mass(arr, labels[0], range(1, labels[1]))
        #return pixels associated with a center
        if return_pixels: dct = return_pixels_associated_w_center(centers, labels)
        del labels, arr
        #filter such that you only keep centers within middle third
        centers = [center for center in centers if (center[0] > overlapping_planes) and (center[0] <= np.min(((numZSlicesPerSplit + overlapping_planes), zdim)))]
        if return_pixels: dct = {c:dct[c] for c in centers}
        
    #adjust z plane to accomodate chunking
    centers = [(xx[0]+start, xx[1], xx[2]) for xx in centers]
    if return_pixels: 
        dct = {tuple((kk[0]+start, kk[1], kk[2])):v for kk,v in dct.iteritems()}
        return dct

    return centers


def return_pixels_associated_w_center(centers, labels, size = (15,100,100)):
    '''Function to return dictionary of k=centers, v=pixels of a given label
    size is the search window from center - done to speed up computation
    ''' 
    dct = {}
    zz,yy,xx = size
    for cen in centers:
        z,y,x = [aa.astype('int') for aa in cen]
        dct[cen] = np.asarray(np.where(labels[0][z-zz:z+zz+1, y-yy:y+yy+1, x-xx:x+xx+1]==labels[0][z,y,x])).T    
    return dct

